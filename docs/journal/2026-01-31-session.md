# Journal de session - 31 janvier 2026

## Contexte

Session de d√©veloppement NeuronSpikes - int√©gration des concepts de l'ancien projet **spikingcortex** (C# .NET, ~2010s) vers Python.

## Objectifs de la session

1. ‚úÖ Int√©grer HebbianLayer dans le visualiseur live
2. ‚úÖ Ajouter le concept Fabric (groupes de neurones avec config partag√©e)
3. ‚úÖ Explorer la r√©tine dans TestVisionCS

---

## 1. Module Synapses (d√©j√† cr√©√©)

Le module `synapses.py` impl√©mente l'apprentissage Hebbien inspir√© de `SpikingNeuron.cs` :

- **Synapse** : Connexion synaptique avec poids, type (excitatory/inhibitory), d√©lai
- **SynapticNetwork** : Gestion index√©e des synapses avec acc√®s rapide
- **HebbianLayer** : Couche avec apprentissage automatique

### R√®gles d'apprentissage (de spikingcortex)

| M√©thode Python | Origine C# | Description |
|----------------|------------|-------------|
| `learn_excitation()` | `updateExitationRelations()` | "Fire together, wire together" |
| `learn_inhibition()` | `updateConcurrencyRelations()` | Inhibition lat√©rale entre concurrents |
| `learn_feedback()` | `updateFeedbackRelations()` | R√©tro-inhibition vers les sources |

**24 tests passent.**

---

## 2. Int√©gration HebbianLayer dans le visualiseur

Modifications apport√©es √† `examples/live_retina.py` :

```python
from neuronspikes import HebbianLayer, SynapticConfig

# Dans VisualizerConfig
show_hebbian: bool = True

# Dans RetinaVisualizer.__init__
self.hebbian_layer: HebbianLayer | None = None
self._hebbian_config = SynapticConfig(...)

# Dans process_frame()
if self.config.show_hebbian and self.neuron_layer.neuron_count > 0:
    if self.hebbian_layer is None:
        self.hebbian_layer = HebbianLayer(...)
    spiked = self.hebbian_layer.process(neuron_activations, learn=True)
    self._last_synapse_count = self.hebbian_layer.network.synapse_count
```

L'affichage montre maintenant `N:X S:Y` (Neurones et Synapses).

---

## 3. Module Fabric

Cr√©√© `fabric.py` bas√© sur `Fabric.cs` de spikingcortex :

### Concept original (C#)

```csharp
public class Fabric : Fibre {
    bool canLearnNewConcepts = false;
    bool canDevelopConcurrency = false;
    bool canDevelopFeedback = false;
    
    public void learnTrough() {
        // Si plusieurs ont spik√© mais aucun maintenant ‚Üí cr√©er nouveau neurone
        if (newlySpiked.Count == 0 && previouslySpiked.Count > 1 && canLearnNewConcepts) {
            SpikingNeuron n = new SpikingNeuron(this);
            n.updateExitationRelations(previouslySpiked, 1.0);
        }
        // D√©velopper concurrence et feedback
        foreach (SpikingNeuron n in newlySpiked) {
            if (canDevelopConcurrency) n.updateConcurrencyRelations(newlySpiked, -1.0);
            if (canDevelopFeedback) n.updateFeedbackRelations(previouslySpiked);
        }
    }
}
```

### Impl√©mentation Python

```python
class LearningCapability(Enum):
    NONE = 0
    LEARN_CONCEPTS = 1      # Peut cr√©er de nouveaux neurones
    DEVELOP_CONCURRENCY = 2  # Inhibition lat√©rale
    DEVELOP_FEEDBACK = 4     # R√©tro-inhibition
    ALL = 7

@dataclass
class FabricConfig:
    name: str = "default"
    learning_capabilities: int = LearningCapability.ALL.value
    max_neurons: int = 1000
    threshold: float = 1.0
    leak: float = 0.1

class Fabric:
    def process(self, activations) -> Set[int]:
        # Traitement + apprentissage automatique
        
    def _learn_through(self):
        # √âquivalent √† learnTrough() C#

class Cortex:
    # Collection de Fabrics sp√©cialis√©s
```

**25 tests passent.**

---

## 4. Exploration de la r√©tine TestVisionCS

### Fichiers analys√©s

| Fichier | Contenu |
|---------|---------|
| `Vision.cs` | M√©thode `See()` - r√©tine circulaire avec triangles |
| `Triangles.cs` | Classe Triangle pour √©chantillonnage/rendu |
| `Form1.cs` | Interface avec r√©tine mobile (suit la souris) |
| `SpikeFrameThread.cs` | LUT bit-reversal (identique √† notre lut.py) |
| `Image2Spikes.cs` | Conversion image ‚Üí spikes avec seuil rotatif |

### R√©tine circulaire (`Vision.See()`)

```csharp
public static Bitmap See(Bitmap src, int cx, int cy, int cz, double theta)
{
    int divisions = 16;  // 16 secteurs angulaires
    double r = Math.PI / (divisions/2);  // largeur angulaire
    
    Triangle[,] triangle = new Triangle[100,16];  // 100 anneaux √ó 16 secteurs
    
    for (int s = 0; cyl <= z; s++, cyl += s) {
        Point a = new Point(cx + cyl * cos(theta), cy + cyl * sin(theta));
        for (int d = 0; d < divisions; d++) {
            double t = theta + (r + d * r);
            Point b = new Point(cx + cyl * cos(t), cy + cyl * sin(t));
            Point c = new Point(cx, cy);  // Centre
            
            triangle[s,d] = new Triangle(a, b, c);
            triangle[s,d].pickColorFromBitmap(bitmapData);  // √âchantillonne
        }
    }
}
```

### R√©tine mobile (saccades simul√©es)

```csharp
private void pictureBoxRetina_MouseMove(object sender, MouseEventArgs e)
{
    // La r√©tine suit le curseur !
    this.pictureBoxRetina.Image = Vision.See(src, e.X, e.Y, 90, 0.0f);
}
```

---

## 5. Observation de Peyo (1995) üê±

St√©phane a partag√© une observation fascinante faite en 1995 :

> "J'√©tais sur une chaise de bureau pivotante avec mon chat Peyo sur les genoux. 
> Pendant que je tournais, Peyo regardait le plafond. J'ai observ√© des **saccades 
> circulaires** dans ses yeux - son iris pivotait par **mouvements discrets** 
> pour compenser ma rotation."

### Insights

1. **R√©flexe vestibulo-oculaire (VOR)** : Compensation des rotations de la t√™te
2. **Quantification angulaire** : Les saccades ont des "pas" discrets, pas continus
3. **Groupes neuronaux** : Sugg√®re N groupes distincts pour N angles de rotation
4. **R√©troaction** : Le cerveau compare image attendue vs r√©elle pour le "match parfait"

### Hypoth√®se

Il existe un **nombre discret de groupes neuronaux** pour la rotation, chacun codant un angle sp√©cifique. Le syst√®me vestibulaire fournit le feedback pour la stabilisation.

C'est coh√©rent avec la th√©orie des **"population codes"** en neurosciences.

---

## 6. √âtat du projet

### Modules (7 total)

| Module | Tests | Description |
|--------|-------|-------------|
| `lut.py` | 21 | LUT bit-reversal + matrice intensity‚Üíspikes |
| `retina.py` | 16 | R√©tine rectangulaire avec seuil rotatif |
| `groups.py` | 18 | D√©tection de groupes d'activation |
| `temporal.py` | 24 | Corr√©lation temporelle des patterns |
| `genesis.py` | 25 | Cr√©ation dynamique de neurones |
| `synapses.py` | 24 | Connexions synaptiques + Hebbien |
| `fabric.py` | 25 | Groupes de neurones avec config partag√©e |
| **Total** | **154** | ‚úÖ Tous passent |

### Prochaines √©tapes possibles

1. **Module `fovea.py`** : R√©tine polaire/circulaire inspir√©e de TestVisionCS
   - Divisions angulaires (secteurs)
   - Anneaux concentriques (r√©solution d√©croissante)
   - Point de fixation mobile (saccades)
   - Groupes de rotation discrets (observation Peyo)
   - M√©canisme de stabilisation VOR

2. **Acc√©l√©ration OpenCL** : Pour les calculs synaptiques massifs

3. **S√©rialisation** : Sauvegarder/charger l'√©tat du r√©seau

---

## R√©f√©rences

- **spikingcortex** : https://github.com/stephanedenis/spikingcortex
- **neuronspikes** : https://github.com/stephanedenis/neuronspikes
- Observation VOR chat : St√©phane Denis, ~1995
